
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ES6一些新特色 - 玫瑰~尘埃</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Aime,"> 
    <meta name="description" content="
ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大,"> 
    <meta name="author" content="Aime"> 
    <link rel="alternative" href="atom.xml" title="玫瑰~尘埃" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">玫瑰~尘埃</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://aimeandis.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">ES6一些新特色</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">ES6一些新特色</h1>
        <div class="stuff">
            <span>五月 23, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/ES6/" rel="tag">ES6</a></li></ul>


        </div>
        <div class="content markdown">
            <blockquote>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
</blockquote>
<p>​    </p>
<p>ES6更新内容主要分为以下几点：</p>
<ul>
<li><strong>表达式</strong>：声明，解构赋值</li>
<li><strong>内置对象：</strong>字符串扩展，数值扩展，对象扩展，数组扩展，函数扩展，正则扩展，Symbol, Set, Map, Proxy, Reflect</li>
<li><strong>语句与运算：</strong>Class, Module, Iterator</li>
<li><strong>异步编程：</strong>Promise, Generator, Async</li>
</ul>
<p>​    </p>
<h3 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p><code>let</code> , <code>const</code>用于声明变量，用来替代<code>var</code>关键字，<code>let</code>用法类似于<code>var</code> , 但是所声明的变量，只能在let命令所在的代码块内有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>for</code> 循环的计数器，就很适合使用<code>let</code>命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// ReferenceError: i is not defined.</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<p>下面代码如果使用 <code>var</code>, 最后输出的是 <strong>10</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p>
<p>​    </p>
<p>如果使用let,声明的变量仅在块级作用域内有效，最后输出的是<strong>6</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<p>​     </p>
<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>

<p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p>
<p>​      </p>
<p><strong>不存在变量提升</strong></p>
<p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">//报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<p>因此，不能在函数内部重新声明 参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>使用const关键字声明一个常量，常量的意思是不会改变的变量，const和let的一些区别是：</p>
<ol>
<li>const声明变量的时候必须赋值，否则会报错，同样使用const声明的变量被修改也会报错。</li>
<li>const 声明变量不能改变，如果声明的是一个引用类型，则不能改变它的内存地址。</li>
</ol>
<hr>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>场景1：内层变量可能会覆盖外层变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p>
<p>​      </p>
<p>场景2：用来计数的循环变量泄露为全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<p>​      </p>
<p>然而在日常开发中没有显式的声明块级作用域，let/const声明的变量却没有变为全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>let</code>,<code>const</code>实际上为 JavaScript 新增了块级作用域。<code>let</code>，<code>const</code>声明的变量是在一个叫script作用域下的,也就是不存在变量提升，这使我们能放心的使用新语法，不用担心污染全局的window对象。</p>
<p>​      </p>
<p><strong>建议</strong></p>
<p>在日常开发中，建议全面拥抱let/const，一般的变量声明使用let关键字，而当声明一些配置项（类似接口地址，npm依赖包，分页器默认页数等一些一旦声明后就不会改变的变量）的时候可以使用const，来显式的告诉项目其他开发者，这个变量是不能改变的(const声明的常量建议使用全大写字母标识,单词间用下划线)。</p>
<p>​      </p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>ES6 允许这样写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>一些栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, ,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">head <span class="comment">//1</span></span><br><span class="line">tail <span class="comment">//[2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,y,...z]=[<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">//"a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>若解构不成功，变量值就等于<code>undefined</code>。</p>
<p>​      </p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo,bar &#125; = &#123; <span class="attr">foo</span>:<span class="string">'aaa'</span>,<span class="attr">bar</span>:<span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// 'aaa'</span></span><br><span class="line">bar <span class="comment">// 'bbb'</span></span><br></pre></td></tr></table></figure>

<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p>
<p>如果解构失败，变量的值等于<code>undefined</code>。</p>
<p>​      </p>
<p>对象的解构赋值是下面形式的简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>
<p>​      </p>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y]</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]].map(<span class="function">(<span class="params">[a,b]</span>) =&gt;</span> a+b);</span><br><span class="line"><span class="comment">// [3,7]</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li><p>交互变量的值</p>
</li>
<li><p>从函数返回多个值</p>
</li>
<li><p>函数参数的定义</p>
</li>
<li><p>提取JSON数据</p>
</li>
<li><p>函数参数的默认值</p>
</li>
<li><p>遍历Map结构</p>
</li>
<li><p>输入模块的指定方法</p>
<p>具体使用方法参照 <a href="https://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ECMAScript 6 入门</a></p>
</li>
</ul>
<p>​      </p>
<p><strong>建议</strong></p>
<p>解构赋值语义化更强，对于作为对象的函数参数来说，可以减少形参的声明，直接使用对象的属性。</p>
<p>另外可以给使用axios的响应结果进行解构（axios默认会把真正的响应结果放在data属性中）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; data &#125; = <span class="keyword">await</span> axios.get(<span class="string">"http://localhost:6000"</span>)</span><br></pre></td></tr></table></figure>



<p>​      </p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用 <strong>箭头</strong> （=&gt;）定义函数</p>
<p>箭头函数对于使用function关键字创建的函数有以下区别</p>
<ol>
<li>箭头函数没有arguments</li>
<li>箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）</li>
<li>箭头函数没有自己的this，箭头函数的this始终等于它上层上下文中的this。（详见另一篇： <a href="https://aimeandis.github.io/2020/05/22/JavaScript-this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/">JavaScript this的指向问题</a>）</li>
</ol>
<p>​      </p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符同样也是ES6的一个重要语法，使用（…），后面跟着一个含有iterator接口的数据结构</p>
<p>​      </p>
<h4 id="在数组中使用"><a href="#在数组中使用" class="headerlink" title="在数组中使用"></a>在数组中使用</h4><p>扩展运算符可以”展开”某个数组，将数组容器拆开，只剩元素集合，将元素集合放到另外一个数组里面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] <span class="comment">// [1,2,3,4,5,6,7,8]</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>可以代替数组原型的concat方法，且语义化更强</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2)) <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="built_in">console</span>.log([...arr1,...arr2]) <span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<h4 id="在对象中使用"><a href="#在对象中使用" class="headerlink" title="在对象中使用"></a>在对象中使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	a:<span class="number">1</span>,</span><br><span class="line">	b:<span class="number">2</span>,</span><br><span class="line">	c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">	...obj,</span><br><span class="line">	d:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">obj2 <span class="comment">// &#123; a:1,b:2,v:3,d:4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>它与Object.assign相似，都可以合并对象，但存在不同，后面讨论</p>
<p><strong>建议</strong></p>
<p>使用扩展运算符可以快速将类数组转换成一个真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>) <span class="comment">// 返回一个nodeList类数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类数组中iteator接口可以使用扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> arr = [...nodeList]</span><br><span class="line"></span><br><span class="line">arr <span class="comment">//所有div的dom组成的数组</span></span><br></pre></td></tr></table></figure>



<p>合并多个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...arr1,...arr2]) <span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h4><p>es6允许当对象的属性和值相同时，省略属性名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const o &#x3D; &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">const o &#x3D; &#123;</span><br><span class="line">  method: function() &#123;</span><br><span class="line">    return &quot;Hello!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当然使用箭头函数也可以这么写</span><br><span class="line">const o &#x3D; &#123;</span><br><span class="line">	method:() &#x3D;&gt; &#123;</span><br><span class="line">		return &quot;Hello!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h4><h4 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h4><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure>

<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><p><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</p>
</li>
<li><p><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</p>
</li>
<li><p><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</p>
</li>
<li><p><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</p>
</li>
</ul>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6 一共有5种方法可以遍历对象的属性。</p>
<ol>
<li><p><strong>for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>Objec.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
</li>
</ol>
<ol start="3">
<li><p><strong>Objec.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p>​    </p>
</li>
<li><p><strong>Objec.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p>​    </p>
</li>
<li><p><strong>Reflect.pwnKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<h3 id="for-…-of循环"><a href="#for-…-of循环" class="headerlink" title="for … of循环"></a>for … of循环</h3><p>for … of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构并且返回各项的值，和for … in的区别如下：</p>
<ol>
<li>for … of只能用在可迭代对象上,获取的是迭代器返回的value值,for … in 可以获取所有对象的键名</li>
<li>for … in会遍历对象的整个原型链,性能非常差不推荐使用,而for … of只遍历当前对象不会遍历它的原型链</li>
<li>对于数组的遍历,for … in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),for … of只返回数组的下标对应的属性值</li>
</ol>
<p>​     </p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise改变了JS的异步编程，现代前端大部分的异步请求都是使用Promise实现，fetch这个web api也是基于Promise的，这里简述下之前战略JS异步编程的回调函数</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>JS是单线程的，但是浏览器是多线程的，这使得JS同时具有异步的操作，即定时器，请求，事件监听等，这个时候就需要一套事件的处理机制去决定这些事件的顺序，即Even Loop（事件循环），前端发出的请求，一般都是进入浏览器的http请求线程，等到收到响应的时候会通过回调函数推入异步队列，等处理完主线程的任务会读取异步队列中任务，执行回调</p>
<p>使用第三方请求库你可能会这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">"http://localhost:3000"</span>,()=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"扣除1000"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>收到响应后，执行后面的回调打印字符串，但是如果这个第三方库有类似超时重试的功能，可能会执行多次你的回调函数，如果是一个支付功能，你会发现扣的钱可能不止1000</p>
<p>​     </p>
<p>另外，如果在回调函数中再嵌套回调函数会导致代码非常难以维护，即“回调地狱”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">"http://localhost:3000"</span>,()=&gt;&#123;</span><br><span class="line">	ajax(<span class="string">"http://localhost:3001"</span>,()=&gt;&#123;</span><br><span class="line">		ajax(<span class="string">"http://localhost:3002"</span>,()=&gt;&#123;</span><br><span class="line">			ajax(<span class="string">"http://localhost:3003"</span>,()=&gt;&#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果你使用的第三方ajax库还有可能并没有提供一些错误的回调，请求失败的一些错误信息会被吞掉，而你却不知情</p>
<p>​      </p>
<p>总结回调函数缺点</p>
<ul>
<li><p>多重嵌套，回调地狱</p>
</li>
<li><p>代码跳跃</p>
</li>
<li><p>信任问题，不知道第三方库是否多次执行回调</p>
</li>
<li><p>第三方库可能没有提供错误处理</p>
</li>
<li><p>不清楚回调是否都是异步调用 （可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"GET"</span>,<span class="string">"/try/ajax/ajax_info.txt"</span>,<span class="literal">false</span>); </span><br><span class="line"><span class="comment">//通过设置第三个async为false可以同步调用ajax</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h4><p>Promise是一个构造函数，通过new关键字创建一个Promise实例，Promise可以很好的解决回调函数的这些问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		resolve(<span class="string">'I have been resolved'</span>)</span><br><span class="line">	&#125;，<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res) <span class="comment">//2秒后打印字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>1.<strong>多重嵌套，回调地狱</strong></p>
<p>Promise在设计的时候引入了链式调用的概念，每个then方法<strong>同样也是一个Pomise</strong>,因此可以无限链式调用下去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> axios.get(<span class="string">"http://localhost:3001"</span>))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> axios.get(<span class="string">"http://localhost:3002"</span>))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> axios.get(<span class="string">"http://localhost:3003"</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>配合箭头函数，比之前回调函数的多层嵌套优雅很多</p>
<p>​    </p>
<p>2.<strong>代码跳跃</strong></p>
<p>Promise使得能够同步思维书写代码，上述的代码就是先请求3000端口，得到响应后再请求3001，再请求3002，再请求3003，而书写的格式也是符合人类的思维，从先到后</p>
<p>​    </p>
<p>3<strong>.信任问题</strong></p>
<p>Promise本身是一个状态机，具有以下3个状态</p>
<ol>
<li>pending(等待)</li>
<li>fulfilled(成功)</li>
<li>rejected(拒绝)</li>
</ol>
<p>​    </p>
<p>当请求发送没有得到响应的时候为pending状态，得到响应后会resolve(决议)当前这个Promise实例,将它变为fulfilled/rejected(大部分情况会变为fulfilled)</p>
<p>当请求发生错误后会执行reject(拒绝)将这个Promise实例变为rejected状态</p>
<p>一个Promise实例的状态只能从pending =&gt; fulfilled 或者从 pending =&gt; rejected，即当一个Promise实例从pending状态改变后，就不会再改变了（不存在fulfilled =&gt; rejected 或 rejected =&gt; fulfilled）</p>
<p>而Promise实例必须主动调用then方法，才能将值从Promise实例中取出来（前提是Promise不是pending状态），这一个“主动”的操作就是解决这个问题的关键，即第三方库做的只是改变Promise的状态，而响应的值怎么处理，这是开发者主动控制的，这里就实现了控制反转，将原来第三方库的控制权转移到了开发者上</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>) <span class="comment">//当收到响应时，这个promise的状态就变成resolve，但是拿到值需要用户主动调用then方法</span></span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>)</span><br><span class="line">	.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//主动调用then方法获取值后用户可以自己决定拿到这个值干什么</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>​    4.第三方库可能没有提供错误处理</p>
<p>Promise的then方法会接受两个函数，第一个函数是这个Promise实例被resolve时执行的回调，第二个函数是这个Promise实例被reject时执行的回调，而这个也是开发者主动调用的</p>
<p>使用Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">// do something&#125;,err=&gt;&#123; 错误处理 &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise提供的catch方法也是相同的效果</span></span><br><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">// do something &#125;)</span></span><br><span class="line">	.catch(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">// catch err &#125;)</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    5.不清楚回调是否都是异步调用的</p>
<p>Promise在设计的时候保证所有响应的处理函数都是异步调用的，不会阻塞代码的执行，Promise将then方法的回调放入一个叫微任务的队列中（MicroTask）,确保这些回调任务在同步任务执行完以后在执行，这部分同样也是事件循环的知识点</p>
<p>​      </p>
<p><strong>建议</strong></p>
<p>在日常开发中，建议全面使用新的Promise语法</p>
<p>建议使用ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise,await可以实现一个“等待”的功能，async/await被称为异步编程的终极解决方法，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行以及在发生异步的错误时提供更精确的错误信息，详细用法可以看阮老师的ES6标准入门</p>
<p>​      </p>
<h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>在ES6 Module出现之前，模块化一直是前端开发者讨论的重点，面对日益增长的需求和代码，需要一种方案来将臃肿的代码拆分成一个个小模块，从而推出了AMD，CMD和CommonJs这三种模块化方案，前者用在浏览器端，后面两种用在服务端，直到ES6 Module出现</p>
<p><strong>ES6 Module默认目前还没有被浏览器支持，需要使用babel，在日常写demo的时候经常会显示语法错误</strong></p>
<p>可以在script标签中使用type=”module”在<strong>同域</strong>的情况下可以解决</p>
<p>​      </p>
<p>ES6 Module使用import关键字导入模块，export关键字导出模块，它还有以下特点</p>
<ul>
<li>ES6 Module 是静态的，也就是说它是在编译阶段运行，和var以及function一样具有提升效果</li>
<li>自动采用严格模式（顶层的this返回undefined）</li>
<li>ES6 Module支持使用export  { &lt;变量&gt; }导出具名的接口，或者export default导出匿名的接口</li>
</ul>
<p>​      module.js导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">20</span></span><br><span class="line"><span class="keyword">export</span> &#123;x&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> y</span><br></pre></td></tr></table></figure>

<p>​    a.js导入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;x&#125; <span class="keyword">from</span> <span class="string">"./module.js"</span></span><br><span class="line"><span class="keyword">import</span> y <span class="keyword">from</span> <span class="string">'./module.js'</span></span><br></pre></td></tr></table></figure>

<p>两者区别在于，export { &lt;变量&gt; }导出的是一个变量的引用，export default导出的是一个值</p>
<p>在a.js中使用import导入这两个变量后，在module.js中因为某些原因x变量被改变了，那么会立刻反映到a.js，而module.js中的y变量改变后，a.js中的y还是原来的那个值</p>
<p>​      </p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy作为一个“拦截器”，可以在目标对象前架设一个拦截器，他人访问对象，必须先经过这层拦截器，Proxy同样是一个构造函数，使用new关键字生成一个拦截对象的实例。</p>
<p>​      </p>
<p>声明：<code>const proxy = new Proxy(target,handler)</code></p>
<p>参数说明</p>
<ul>
<li>target 拦截的目标对象</li>
<li>handler 定制拦截行为</li>
</ul>
<p>​      </p>
<p>拦截方式</p>
<ul>
<li>get()    拦截对象属性读取</li>
<li>set()     拦截对象属性设置，返回布尔</li>
<li>has()    拦截对象属性检查 <code>k in obj</code>，返回布尔</li>
<li>deleteProperty()    拦截对象属性删除 <code>delete obj[k]</code>，返回布尔</li>
<li>defineProperty()    拦截对象属性定义 <code>Object.defineProperty()</code>，<code>Object.defineProperties()</code>，返回布尔</li>
<li>apply()    拦截Proxy实例作为函数调用 <code>proxy()</code>，<code>proxy.apply()</code>，<code>proxy.call()</code></li>
</ul>
<p>ES6提供了非常多对象 拦截的操作，几乎覆盖了所有可能修改目标对象的情况（Proxy一般和Reflect配套使用，前者拦截对象，后者返回拦截的结果，Proxy上有的 拦截方法Reflect都有）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;</span><br><span class="line">	<span class="keyword">set</span>(target,key,val)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'oops'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.foo = <span class="string">'bar'</span> <span class="comment">// 'oops'</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>这个ES6新增的Object静态方法允许进行多个对象的合并</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj =<span class="built_in">Object</span>.assign(target,&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line">obj <span class="comment">// &#123;a:1,b:2&#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign遍历需要合并给target的对象的属性，用等号进行赋值，上面遍历{a:1}将属性a和值1赋值给target对象，然后再遍历{b:2}将属性b和值2赋值给target对象</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
